<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>preBuild for hp2025 - Mode Selector</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/1.0.11/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.min.js"></script>
    <style>
        :root { --primary: #2196F3; --accent: #d32f2f; --bg: #eef2f3; }
        body { font-family: sans-serif; background: var(--bg); text-align: center; padding: 20px; color: #333; margin: 0; }
        
        .header-ui { position: sticky; top: 0; background: var(--bg); padding: 10px; z-index: 100; border-bottom: 2px solid #ccc; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        #preview-area { 
            width: 320px; height: 270px; margin: 10px auto; 
            background-color: #eee; border: 2px solid #ccc; border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            background-image: linear-gradient(45deg, #ddd 25%, transparent 25%), linear-gradient(-45deg, #ddd 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ddd 75%), linear-gradient(-45deg, transparent 75%, #ddd 75%);
            background-size: 20px 20px; position: relative; cursor: pointer;
        }
        canvas { max-width: 100%; max-height: 100%; }

        .mode-selector { background: #fff; padding: 10px; border-radius: 8px; margin-bottom: 10px; display: inline-flex; gap: 15px; align-items: center; border: 1px solid #ccc; }
        .main-controls { display: flex; justify-content: center; gap: 8px; flex-wrap: wrap; margin-bottom: 10px; }
        
        button { padding: 10px 16px; font-weight: bold; cursor: pointer; border-radius: 6px; border: none; color: white; transition: 0.2s; font-size: 13px; }
        .btn-blue { background: var(--primary); }
        .btn-green { background: #009688; }
        .btn-red { background: var(--accent); box-shadow: 0 4px #b71c1c; }
        .btn-toggle { background: #673ab7; }
        .btn-save-db { background: #607D8B; }
        
        #frames-list { display: flex; flex-direction: column; align-items: center; gap: 6px; margin-top: 20px; padding-bottom: 50px; }
        .frame-item { background: white; padding: 8px; border-radius: 8px; display: flex; align-items: center; gap: 10px; width: 450px; border: 1px solid #ddd; }
        .thumb { width: 40px; height: 40px; object-fit: contain; background: #f9f9f9; border: 1px solid #eee; }
        .frame-info { font-weight: bold; width: 25px; font-size: 12px; color: #888; }
        .item-ctrls { display: flex; gap: 4px; margin-left: auto; }
        .btn-mini { padding: 4px 8px; font-size: 10px; background: #9e9e9e; color: white; border: none; border-radius: 4px; }
        .btn-del { background: #ff5252; }
        
        label { font-size: 14px; font-weight: bold; cursor: pointer; }
    </style>
</head>
<body>

    <div class="header-ui">
        <h1>preBuild for hp2025</h1>
        
        <div class="mode-selector">
            <span>設定：</span>
            <label><input type="radio" name="fps" value="100" onchange="changeMode(100, 10)"> 0.1秒 (10枚/計1s)</label>
            <label><input type="radio" name="fps" value="200" onchange="changeMode(200, 20)" checked> 0.2秒 (20枚/計4s)</label>
        </div>

        <div id="preview-area" onclick="togglePreview()">
            <canvas id="main-canvas" width="320" height="270"></canvas>
            <div id="play-state-label" style="position:absolute; bottom:5px; background:rgba(0,0,0,0.5); color:white; padding:2px 8px; border-radius:10px; font-size:10px;">再生中</div>
        </div>

        <div class="main-controls">
            <button class="btn-toggle" id="btn-play-pause" onclick="togglePreview()">一時停止</button>
            <button class="btn-blue" onclick="document.getElementById('bulk-upload').click()">一括アップロード</button>
            <input type="file" id="bulk-upload" multiple accept="image/*" style="display:none" onchange="handleBulkUpload(this)">
            <button class="btn-green" onclick="autoFill()">自動充填</button>
            <button class="btn-save-db" onclick="restoreFromDB()">復元</button>
            <button class="btn-red" onclick="saveForLine()">APNG保存</button>
        </div>
    </div>

    <div id="frames-list"></div>

<script>
    let currentDelay = 200;
    let maxFramesLimit = 20;
    let frameBuffers = new Array(20).fill(null);
    let isPlaying = true;
    let previewTimer = null;
    let currentPreviewIdx = 0;
    const mainCtx = document.getElementById('main-canvas').getContext('2d');

    // DB機能
    const DB_NAME = "hp2025_DB_v3", STORE_NAME = "frames";
    function openDB() {
        return new Promise(resolve => {
            const req = indexedDB.open(DB_NAME, 1);
            req.onupgradeneeded = () => req.result.createObjectStore(STORE_NAME);
            req.onsuccess = () => resolve(req.result);
        });
    }
    async function saveToDB() {
        const db = await openDB();
        const tx = db.transaction(STORE_NAME, "readwrite");
        tx.objectStore(STORE_NAME).put({buffers: frameBuffers, delay: currentDelay, limit: maxFramesLimit}, "current_project");
    }
    async function restoreFromDB() {
        const db = await openDB();
        const req = db.transaction(STORE_NAME).objectStore(STORE_NAME).get("current_project");
        req.onsuccess = () => {
            if (req.result) {
                frameBuffers = req.result.buffers;
                currentDelay = req.result.delay;
                maxFramesLimit = req.result.limit;
                document.querySelector(`input[value="${currentDelay}"]`).checked = true;
                renderList();
                alert("データを復元しました。");
            }
        };
    }

    // モード切り替え
    function changeMode(delay, limit) {
        currentDelay = delay;
        maxFramesLimit = limit;
        // 制限枚数以上のデータがあればカットする警告
        const activeCount = frameBuffers.filter((b, i) => b && i >= limit).length;
        if (activeCount > 0) {
            if (!confirm(`0.1sモードに変更すると、11枚目以降のデータは無視されます。よろしいですか？`)) {
                document.querySelector(`input[value="200"]`).checked = true;
                currentDelay = 200; maxFramesLimit = 20;
                return;
            }
        }
        renderList();
        saveToDB();
        startPreview();
    }

    function renderList() {
        const list = document.getElementById('frames-list');
        list.innerHTML = '';
        for (let i = 0; i < maxFramesLimit; i++) {
            const buf = frameBuffers[i];
            const div = document.createElement('div');
            div.className = 'frame-item';
            const thumbSrc = buf ? arrayBufferToDataURL(buf) : '';
            div.innerHTML = `
                <span class="frame-info">${i+1}</span>
                <img src="${thumbSrc}" class="thumb" id="img-${i}" style="${!buf ? 'opacity:0.1' : ''}">
                <input type="file" accept="image/*" onchange="loadSingle(${i}, this)" style="width:120px; font-size:10px;">
                <div class="item-ctrls">
                    <button class="btn-mini" onclick="moveFrame(${i}, -1)">▲</button>
                    <button class="btn-mini" onclick="moveFrame(${i}, 1)">▼</button>
                    <button class="btn-mini btn-del" onclick="deleteFrame(${i})">消</button>
                </div>
            `;
            list.appendChild(div);
        }
    }

    async function loadSingle(i, input) {
        const file = input.files[0];
        if (!file) return;
        frameBuffers[i] = await processImage(file);
        renderList();
        saveToDB();
    }

    async function handleBulkUpload(input) {
        const files = Array.from(input.files);
        let fIdx = 0;
        for (let i = 0; i < maxFramesLimit && fIdx < files.length; i++) {
            if (!frameBuffers[i]) {
                frameBuffers[i] = await processImage(files[fIdx]);
                fIdx++;
            }
        }
        renderList();
        saveToDB();
    }

    function processImage(file) {
        return new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const cvs = document.createElement('canvas');
                    cvs.width = 320; cvs.height = 270;
                    const c = cvs.getContext('2d');
                    const s = Math.min(300/img.width, 250/img.height);
                    c.drawImage(img, (320-img.width*s)/2, (270-img.height*s)/2, img.width*s, img.height*s);
                    resolve(c.getImageData(0,0,320,270).data.buffer);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    }

    function deleteFrame(i) {
        frameBuffers[i] = null;
        renderList();
        saveToDB();
    }

    function moveFrame(i, dir) {
        const target = i + dir;
        if (target < 0 || target >= maxFramesLimit) return;
        [frameBuffers[i], frameBuffers[target]] = [frameBuffers[target], frameBuffers[i]];
        renderList();
        saveToDB();
    }

    function autoFill() {
        if (!frameBuffers[1] || !frameBuffers[2]) return alert("2枚目と3枚目が必要です");
        for (let i = 3; i < maxFramesLimit; i++) {
            frameBuffers[i] = (i % 2 === 1) ? frameBuffers[1] : frameBuffers[2];
        }
        renderList();
        saveToDB();
    }

    function togglePreview() {
        isPlaying = !isPlaying;
        document.getElementById('btn-play-pause').innerText = isPlaying ? "一時停止" : "再生";
        document.getElementById('play-state-label').innerText = isPlaying ? "再生中" : "停止中";
        if (isPlaying) startPreview();
        else if (previewTimer) clearInterval(previewTimer);
    }

    function startPreview() {
        if (previewTimer) clearInterval(previewTimer);
        previewTimer = setInterval(() => {
            if (!isPlaying) return;
            const active = frameBuffers.slice(0, maxFramesLimit).map((b, i) => b ? i : null).filter(v => v !== null);
            if (active.length === 0) return;
            currentPreviewIdx = active[(active.indexOf(currentPreviewIdx) + 1) % active.length];
            if (currentPreviewIdx === undefined || currentPreviewIdx >= maxFramesLimit) currentPreviewIdx = active[0];
            const idata = new ImageData(new Uint8ClampedArray(frameBuffers[currentPreviewIdx]), 320, 270);
            mainCtx.putImageData(idata, 0, 0);
        }, currentDelay); 
    }

    function arrayBufferToDataURL(buf) {
        const cvs = document.createElement('canvas');
        cvs.width = 320; cvs.height = 270;
        cvs.getContext('2d').putImageData(new ImageData(new Uint8ClampedArray(buf), 320, 270), 0, 0);
        return cvs.toDataURL();
    }

    function saveForLine() {
        const active = frameBuffers.slice(0, maxFramesLimit).filter(b => b !== null);
        if (active.length < 5) return alert("最低5フレーム必要です。");
        
        const apng = UPNG.encode(active, 320, 270, 0, new Array(active.length).fill(currentDelay));
        const view = new DataView(apng);
        let offset = 8;
        while (offset < apng.byteLength) {
            const len = view.getUint32(offset), type = view.getUint32(offset + 4);
            if (type === 0x6163544C) { view.setUint32(offset + 12, 1); break; }
            offset += 12 + len;
        }
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([apng], {type: 'image/png'}));
        a.download = `line_${active.length}f_${currentDelay}ms.png`;
        a.click();
    }

    renderList();
    startPreview();
</script>
</body>
</html>
