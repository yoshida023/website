<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>preBuild for hp2025 - Professional Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/1.0.11/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.min.js"></script>
    <style>
        :root { --primary: #2196F3; --accent: #ff5252; --bg: #121212; --card: #1e1e1e; --text: #eee; --checker: #333; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Yu Gothic", sans-serif; background: var(--bg); color: var(--text); margin: 0; padding: 0; }
        
        /* 透過確認用格子模様 */
        .transparent-bg {
            background-color: #222;
            background-image: linear-gradient(45deg, var(--checker) 25%, transparent 25%), linear-gradient(-45deg, var(--checker) 25%, transparent 25%), linear-gradient(45deg, transparent 75%, var(--checker) 75%), linear-gradient(-45deg, transparent 75%, var(--checker) 75%);
            background-size: 10px 10px;
        }

        /* 固定ヘッダー（プレビュー） */
        .sticky-header { position: sticky; top: 0; background: var(--bg); z-index: 100; border-bottom: 2px solid #333; padding-bottom: 10px; }
        #preview-area { 
            width: 200px; height: 168px; margin: 10px auto; 
            border: 2px solid #444; border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            position: relative; cursor: pointer;
        }
        canvas { max-width: 100%; max-height: 100%; }
        #play-state-overlay { position: absolute; font-size: 12px; background: rgba(0,0,0,0.6); padding: 4px 12px; border-radius: 20px; color: #fff; bottom: 5px; }

        .top-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; padding: 0 10px; }
        button { padding: 12px 5px; font-weight: bold; border-radius: 8px; border: none; color: white; font-size: 13px; transition: 0.2s; }
        .btn-blue { background: var(--primary); }
        .btn-green { background: #00897b; }
        .btn-red { background: var(--accent); }
        .btn-gray { background: #444; }

        /* メインフレーム専用エリア */
        .main-frame-section { background: #252525; padding: 15px; margin: 10px; border-radius: 12px; border: 1px solid #3d8bff; }
        .section-title { font-size: 12px; font-weight: bold; color: var(--primary); margin-bottom: 8px; text-align: left; }

        /* リストスタイル */
        #frames-list { padding: 0 10px 100px; display: flex; flex-direction: column; gap: 12px; }
        .frame-item { background: var(--card); padding: 12px; border-radius: 12px; display: flex; align-items: center; gap: 15px; border: 1px solid #333; }
        .img-container { width: 80px; height: 80px; border-radius: 6px; overflow: hidden; border: 1px solid #444; flex-shrink: 0; display: flex; align-items: center; justify-content: center; }
        .img-container img { max-width: 100%; max-height: 100%; }
        
        .frame-info { font-size: 18px; font-weight: bold; color: #666; width: 25px; }
        .file-input { flex-grow: 1; font-size: 12px; }
        .item-ctrls { display: flex; flex-direction: column; gap: 6px; }
        .btn-mini { padding: 8px; font-size: 14px; background: #333; border-radius: 6px; }
        .btn-del { color: var(--accent); }
    </style>
</head>
<body>

    <div class="sticky-header">
        <div id="preview-area" class="transparent-bg" onclick="togglePreview()">
            <canvas id="main-canvas" width="320" height="270"></canvas>
            <div id="play-state-overlay">TAP TO PLAY</div>
        </div>

        <div class="top-controls">
            <div style="grid-column: 1/-1; background:#222; padding:8px; border-radius:8px; margin-bottom:5px; font-size:12px;">
                速度: <label><input type="radio" name="fps" value="100" onchange="changeMode(100)"> 0.1s</label>
                <label style="margin-left:15px;"><input type="radio" name="fps" value="200" onchange="changeMode(200)" checked> 0.2s</label>
            </div>
            <button class="btn-blue" onclick="document.getElementById('bulk-upload').click()">一括読込</button>
            <input type="file" id="bulk-upload" multiple accept="image/*" style="display:none" onchange="handleBulkUpload(this)">
            <button class="btn-green" onclick="smartFill()">パターン自動充填</button>
            <button class="btn-gray" onclick="restoreFromDB()">復元</button>
            <button class="btn-red" onclick="saveForLine()">APNG保存</button>
        </div>
    </div>

    <div class="main-frame-section" id="main-frame-root"></div>

    <div id="frames-list"></div>

<script>
    let currentDelay = 200;
    const MAX_FRAMES = 20;
    let frameBuffers = new Array(MAX_FRAMES).fill(null);
    let isPlaying = false;
    let previewTimer = null;
    let currentPreviewIdx = 0;
    const mainCtx = document.getElementById('main-canvas').getContext('2d');

    const DB_NAME = "hp2025_mobile_v2", STORE_NAME = "frames";
    function openDB() {
        return new Promise(resolve => {
            const req = indexedDB.open(DB_NAME, 1);
            req.onupgradeneeded = () => req.result.createObjectStore(STORE_NAME);
            req.onsuccess = () => resolve(req.result);
        });
    }
    async function saveToDB() {
        const db = await openDB();
        const tx = db.transaction(STORE_NAME, "readwrite");
        tx.objectStore(STORE_NAME).put({buffers: frameBuffers, delay: currentDelay}, "current_project");
    }
    async function restoreFromDB() {
        const db = await openDB();
        const req = db.transaction(STORE_NAME).objectStore(STORE_NAME).get("current_project");
        req.onsuccess = () => {
            if (req.result) {
                frameBuffers = req.result.buffers;
                currentDelay = req.result.delay;
                document.querySelector(`input[value="${currentDelay}"]`).checked = true;
                renderAll();
                updateStaticPreview();
                alert("復元しました");
            }
        };
    }

    function changeMode(delay) {
        currentDelay = parseInt(delay);
        saveToDB();
        if (isPlaying) startPreview();
    }

    function renderAll() {
        const list = document.getElementById('frames-list');
        const mainRoot = document.getElementById('main-frame-root');
        list.innerHTML = '';
        mainRoot.innerHTML = '<div class="section-title">MAIN (FRAME 1)</div>';

        for (let i = 0; i < MAX_FRAMES; i++) {
            const buf = frameBuffers[i];
            const thumbSrc = buf ? arrayBufferToDataURL(buf) : '';
            const html = `
                <div class="img-container transparent-bg">
                    <img src="${thumbSrc || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'}" style="${!buf ? 'opacity:0' : ''}">
                </div>
                <div class="file-input">
                    <input type="file" accept="image/*" onchange="loadSingle(${i}, this)" style="width:100%">
                </div>
                <div class="item-ctrls">
                    ${i > 0 ? `<button class="btn-mini" onclick="moveFrame(${i}, -1)">▲</button>
                               <button class="btn-mini" onclick="moveFrame(${i}, 1)">▼</button>` : ''}
                    <button class="btn-mini btn-del" onclick="deleteFrame(${i})">×消</button>
                </div>
            `;

            if (i === 0) {
                const div = document.createElement('div');
                div.className = 'frame-item';
                div.style.borderColor = "#3d8bff";
                div.innerHTML = html;
                mainRoot.appendChild(div);
            } else {
                const div = document.createElement('div');
                div.className = 'frame-item';
                div.innerHTML = `<span class="frame-info">${i+1}</span>` + html;
                list.appendChild(div);
            }
        }
    }

    async function loadSingle(i, input) {
        const file = input.files[0];
        if (!file) return;
        frameBuffers[i] = await processImage(file);
        renderAll();
        saveToDB();
        updateStaticPreview();
    }

    async function handleBulkUpload(input) {
        const files = Array.from(input.files);
        let fIdx = 0;
        for (let i = 0; i < MAX_FRAMES && fIdx < files.length; i++) {
            if (!frameBuffers[i]) {
                frameBuffers[i] = await processImage(files[fIdx]);
                fIdx++;
            }
        }
        renderAll();
        saveToDB();
        updateStaticPreview();
    }

    function processImage(file) {
        return new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const cvs = document.createElement('canvas');
                    cvs.width = 320; cvs.height = 270;
                    const c = cvs.getContext('2d');
                    const s = Math.min(320/img.width, 270/img.height);
                    c.drawImage(img, (320-img.width*s)/2, (270-img.height*s)/2, img.width*s, img.height*s);
                    resolve(c.getImageData(0,0,320,270).data.buffer);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    }

    function deleteFrame(i) {
        frameBuffers[i] = null;
        renderAll();
        saveToDB();
    }

    function moveFrame(i, dir) {
        const target = i + dir;
        if (target < 0 || target >= MAX_FRAMES) return;
        [frameBuffers[i], frameBuffers[target]] = [frameBuffers[target], frameBuffers[i]];
        renderAll();
        saveToDB();
    }

    function smartFill() {
        // 2枚目以降のパターンを取得
        const pattern = frameBuffers.slice(1).filter(b => b !== null);
        if (pattern.length < 1) return alert("2フレーム目以降に画像を配置してください");
        
        for (let i = 1; i < MAX_FRAMES; i++) {
            if (frameBuffers[i] === null) {
                // i-1で調整してループさせる
                frameBuffers[i] = pattern[(i - 1) % pattern.length];
            }
        }
        renderAll();
        saveToDB();
    }

    function togglePreview() {
        isPlaying = !isPlaying;
        document.getElementById('play-state-overlay').innerText = isPlaying ? "PLAYING" : "PAUSED";
        if (isPlaying) startPreview();
        else if (previewTimer) clearInterval(previewTimer);
    }

    function startPreview() {
        if (previewTimer) clearInterval(previewTimer);
        previewTimer = setInterval(() => {
            const active = frameBuffers.map((b, i) => b ? i : null).filter(v => v !== null);
            if (active.length === 0) return;
            currentPreviewIdx = active[(active.indexOf(currentPreviewIdx) + 1) % active.length];
            if (currentPreviewIdx === undefined) currentPreviewIdx = active[0];
            updateStaticPreview(currentPreviewIdx);
        }, currentDelay); 
    }

    function updateStaticPreview(idx = null) {
        const targetIdx = idx !== null ? idx : frameBuffers.findIndex(b => b !== null);
        if (targetIdx === -1) return;
        mainCtx.clearRect(0,0,320,270);
        mainCtx.putImageData(new ImageData(new Uint8ClampedArray(frameBuffers[targetIdx]), 320, 270), 0, 0);
    }

    function arrayBufferToDataURL(buf) {
        const cvs = document.createElement('canvas');
        cvs.width = 320; cvs.height = 270;
        cvs.getContext('2d').putImageData(new ImageData(new Uint8ClampedArray(buf), 320, 270), 0, 0);
        return cvs.toDataURL();
    }

    function saveForLine() {
        const active = frameBuffers.filter(b => b !== null);
        if (active.length < 5) return alert("最低5フレーム必要です");
        const apng = UPNG.encode(active, 320, 270, 0, new Array(active.length).fill(currentDelay));
        const view = new DataView(apng);
        let offset = 8;
        while (offset < apng.byteLength) {
            const len = view.getUint32(offset), type = view.getUint32(offset + 4);
            if (type === 0x6163544C) { view.setUint32(offset + 12, 1); break; }
            offset += 12 + len;
        }
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([apng], {type: 'image/png'}));
        a.download = `line_stamp.png`;
        a.click();
    }

    renderAll();
</script>
</body>
</html>
